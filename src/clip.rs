#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use std::borrow::BorrowMut;

use crate::point::Point2D;
use crate::polygon::Polygon;
use anyhow::Result;
use num_traits::NumCast;
use num_traits::ToPrimitive;

// Include the bindings generated by bindgen
include!(concat!(env!("OUT_DIR"), "/gpc.rs"));

pub struct ManagedGpcPolygon {
    pub polygon: gpc_polygon,
    _contours: Box<[gpc_vertex_list]>, // Boxed slice of contours to keep it alive
    _vertices: Box<[gpc_vertex]>,      // Boxed slice of vertices to keep them alive
}

impl ManagedGpcPolygon {
    pub fn to_polygon<P>(self) -> P
    where
        P: Polygon + From<Vec<P::Point>>,
    {
        let mut points: Vec<<P as Polygon>::Point> = Vec::new();

        // Iterate over contours
        for contour_index in 0..self.polygon.num_contours {
            unsafe {
                let vertex_list = *self.polygon.contour.add(contour_index as usize);

                // Iterate over vertices
                for vertex_index in 0..vertex_list.num_vertices {
                    let vertex = *vertex_list.vertex.add(vertex_index as usize);
                    let point = <P as Polygon>::Point::from_xy(
                        <<<P as Polygon>::Point as Point2D>::Value as NumCast>::from(vertex.x)
                            .unwrap(),
                        <<<P as Polygon>::Point as Point2D>::Value as NumCast>::from(vertex.y)
                            .unwrap(),
                    );
                    points.push(point);
                }
            }
        }

        // Build your polygon from the points
        P::from(points)
    }
}

impl<P> From<&P> for ManagedGpcPolygon
where
    P: Polygon,
{
    fn from(polygon: &P) -> Self {
        let num_contours = 1; // Assuming one contour for simplicity

        // Collect vertices into a boxed slice to ensure the memory stays valid
        let vertices: Box<[gpc_vertex]> = polygon
            .iter_vertices()
            .map(|vertex| gpc_vertex {
                x: vertex.x().to_f64().unwrap(),
                y: vertex.y().to_f64().unwrap(),
            })
            .collect::<Vec<_>>()
            .into_boxed_slice();

        // Create the gpc_vertex_list and store it in a boxed slice
        let contour = gpc_vertex_list {
            num_vertices: vertices.len() as ::std::os::raw::c_int,
            vertex: vertices.as_ptr() as *mut gpc_vertex, // Use pointer from boxed slice
        };

        let contours: Box<[gpc_vertex_list]> = vec![contour].into_boxed_slice();

        // Create the gpc_polygon, with contour memory managed by Rust
        let polygon = gpc_polygon {
            num_contours,
            hole: std::ptr::null_mut(), // Assuming no holes for simplicity
            contour: contours.as_ptr() as *mut gpc_vertex_list,
        };

        ManagedGpcPolygon {
            polygon,
            _contours: contours,
            _vertices: vertices,
        }
    }
}

pub enum ClipOp {
    Union,
    Intersection,
    Difference,
    Xor,
}

pub trait Clippable: Polygon + From<Vec<Self::Point>> {
    fn clip_polygon(&self, other: &Self, op: ClipOp) -> Result<Vec<Self>> {
        let set_operation = match op {
            ClipOp::Union => gpc_op_GPC_UNION,
            ClipOp::Intersection => gpc_op_GPC_INT,
            ClipOp::Difference => gpc_op_GPC_DIFF,
            ClipOp::Xor => gpc_op_GPC_XOR,
        };
        let mut self_gpc = ManagedGpcPolygon::from(self);
        let mut other_gpc = ManagedGpcPolygon::from(other);
        let mut result_gpc = gpc_polygon {
            num_contours: 0,
            contour: std::ptr::null_mut(),
            hole: std::ptr::null_mut(),
        };
        unsafe {
            gpc_polygon_clip(
                set_operation,
                self_gpc.polygon.borrow_mut(),
                other_gpc.polygon.borrow_mut(),
                result_gpc.borrow_mut(),
            )
        }
        Ok(Self::from_gpc_polygon(result_gpc))
    }

    fn from_gpc_polygon(gpc_poly: gpc_polygon) -> Vec<Self> {
        let mut contours = vec![];

        // TODO: Output a poylgon for each contour
        // Iterate over contours
        for contour_index in 0..gpc_poly.num_contours {
            let mut points: Vec<<Self as Polygon>::Point> = Vec::new();
            unsafe {
                let vertex_list = *gpc_poly.contour.add(contour_index as usize);

                // Iterate over vertices
                for vertex_index in 0..vertex_list.num_vertices {
                    let vertex = *vertex_list.vertex.add(vertex_index as usize);
                    let point = <Self as Polygon>::Point::from_xy(
                        <<<Self as Polygon>::Point as Point2D>::Value as NumCast>::from(vertex.x)
                            .unwrap(),
                        <<<Self as Polygon>::Point as Point2D>::Value as NumCast>::from(vertex.y)
                            .unwrap(),
                    );
                    points.push(point);
                }
            }
            contours.push(Self::from(points));
        }

        contours
    }
}

mod tests {
    #[test]
    fn test_round_trip_conversion() {
        use crate::clip::ManagedGpcPolygon;
        use crate::kernelf64::{Point2D, Polygon};
        use crate::point::Point2D as _;
        use crate::polygon::Polygon as _;
        let polygon = Polygon::from(vec![
            Point2D::from_xy(0.0, 0.0),
            Point2D::from_xy(1.0, 0.0),
            Point2D::from_xy(1.0, 1.0),
            Point2D::from_xy(0.0, 1.0),
        ]);
        let gpc_polygon = ManagedGpcPolygon::from(&polygon);
        let reconstructed_polygon: Polygon = gpc_polygon.to_polygon();
        reconstructed_polygon
            .iter_vertices()
            .zip(polygon.iter_vertices())
            .for_each(|(a, b)| {
                assert_eq!(a, b);
            });
    }

    #[test]
    fn test_clip_polygon_union() {
        use super::{ClipOp, Clippable};
        use crate::kernelf64::{Point2D, Polygon};
        use crate::point::Point2D as _;
        use crate::polygon::Polygon as _;
        use std::f64::consts::PI;
        let square = Polygon {
            vertices: vec![
                Point2D { x: 0.0, y: 0.0 },
                Point2D { x: 20.0, y: 0.0 },
                Point2D { x: 20.0, y: 20.0 },
                Point2D { x: 0.0, y: 20.0 },
            ],
            offset: Point2D::from_xy(20.0, 20.0),
            rotation: 0.0,
        };

        let triangle = Polygon {
            vertices: vec![
                Point2D { x: 0.0, y: 0.0 },
                Point2D { x: 30.0, y: 0.0 },
                Point2D { x: 15.0, y: 20.0 },
            ],
            offset: Point2D::from_xy(50.0, 15.0),
            rotation: PI / 2.0,
        };

        let union = square.clip_polygon(&triangle, ClipOp::Union).unwrap();

        let expected = vec![Polygon {
            vertices: vec![
                Point2D { x: 50.0, y: 15.0 },
                Point2D { x: 40.0, y: 22.5 },
                Point2D { x: 40.0, y: 20.0 },
                Point2D { x: 20.0, y: 20.0 },
                Point2D { x: 20.0, y: 40.0 },
                Point2D { x: 40.0, y: 40.0 },
                Point2D { x: 40.0, y: 37.5 },
                Point2D { x: 50.0, y: 45.0 },
            ],
            offset: Point2D::from_xy(0.0, 0.0),
            rotation: 0.0,
        }];

        for (a, b) in union.iter().zip(expected.iter()) {
            for (j, k) in a.iter_vertices().zip(b.iter_vertices()) {
                assert_eq!(j, k);
            }
        }
    }
}
